package main

import (
	"encoding/json"
	"fmt"
	"github.com/astaxie/beego"
	"io/ioutil"
	"os"
	"os/exec"
	"time"

	"math"
)

type Results struct {
	Status string      `json:"status"`
	Ip     string      `json:"ip"`
	Type   string      `json:"type"`
	Result []StoreView `json:"result"`
}

func main() {
	//get all static
	str := readConf("/root/go/src/beego_info/static/static")
	static := make([]Results, 0)
	if err := json.Unmarshal([]byte(str), &static); err != nil {
		beego.Error(err)
	}

	var s Statistics
	for _, val := range static {
		var dev Device
		dev.Ip = val.Ip
		info := microAdjust(&val.Result[len(val.Result)-1]) //get the lastest one statistics
		dev.Info = append(dev.Info, info)
		if val.Type == "storeInfo" {
			s.Storages = append(s.Storages, dev)
		} else {
			s.Exports = append(s.Exports, dev)
		}
	}
	fmt.Printf("%+v", s)
}

//get data from local
func InfoStat() {
	go func() {
		str := readConf("/root/go/src/beego_info/static/static")
		static := make([]Results, 0)
		if err := json.Unmarshal([]byte(str), &static); err != nil {
			beego.Error(err)
		}

		var s Statistics
		for _, val := range static {
			var dev Device
			dev.Ip = val.Ip
			info := microAdjust(&val.Result[len(val.Result)-1]) //get the lastest one statistics
			dev.Info = append(dev.Info, info)
			if val.Type == "storeInfo" {
				s.Storages = append(s.Storages, dev)
			} else {
				s.Exports = append(s.Exports, dev)
			}
		}
	}()
}

//make some value from KB to MB or ...
func microAdjust(devInfo *StoreView) StoreView {
	for i, _ := range devInfo.Dfs {
		devInfo.Dfs[i].Total = Round(devInfo.Dfs[i].Total/1024.0/1024.0, 2)
		devInfo.Dfs[i].Available = Round(devInfo.Dfs[i].Available/1024.0/1024.0, 2)
	}

	return *devInfo
}

func Round(f float64, n int) float64 {
	pow10_n := math.Pow10(n)
	return math.Trunc((f+0.5/pow10_n)*pow10_n) / pow10_n
}

func Ansible() {
	go func() {
		for {
			ansibleFrequency, err := beego.AppConfig.Int("ansible")
			if err != nil {
				beego.Error(err)
			}
			if _, err := exec.Command("python", "models/device.py").Output(); err != nil {
				beego.Error(err)
			}
			time.Sleep(time.Duration(ansibleFrequency) * time.Second)
		}
	}()
}

func readConf(path string) string {
	fi, err := os.Open(path)
	if err != nil {
		beego.Error(err)
	}
	defer fi.Close()
	fd, err := ioutil.ReadAll(fi)
	if err != nil {
		beego.Error(err)
	}
	return string(fd)
}

type Statistics struct {
	Exports  []Device `json:"exports"`
	Storages []Device `json:"storages"`
}

type Device struct {
	Info []StoreView `json:"info"`
	Ip   string      `json:"ip"`
}

type StoreView struct {
	Dfs       []Df    `json:"df"`
	Cpu       float64 `json:"cpu"`
	Mem       float64 `json:"mem"`
	Temp      float64 `json:"temp"`
	Write     float64 `json:"write_mb"`
	Read      float64 `json:"read_mb"`
	TimeStamp float64 `json:"timestamp"`
	CacheT    float64 `json:"cache_total"`
	CacheU    float64 `json:"cache_used"`
	W_Vol     float64 `json:"write_vol"`
	R_Vol     float64 `json:"read_vol"`
}

type Df struct {
	Name      string  `json:"name"`
	Total     float64 `json:"total"`
	Available float64 `json:"available"`
	Used_per  float64 `json:"used_per"`
}
